<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - PCD</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<a href="https://pointclouds.org/documentation/tutorials/pcd_file_format.html" target="_blank" rel="noopener">PCD File format</a>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<div id="container"></div>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { PCDLoader } from 'three/addons/loaders/PCDLoader.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let camera, scene, renderer, points, selectedPoints = [];

			init();
			render();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 0.01, 40 );
				camera.position.set( 0, 0, 1 );
				scene.add( camera );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 0.5;
				controls.maxDistance = 10;

				const loader = new PCDLoader();
				loader.load( './models/pcd/binary/bunny.pcd', function ( loadedPoints ) {

					points = loadedPoints;
					points.geometry.center();
					points.geometry.rotateX( Math.PI );
					points.name = 'bunny.pcd';
					scene.add( points );

					const gui = new GUI();

					gui.add( points.material, 'size', 0.001, 0.01 ).onChange( render );
					gui.addColor( points.material, 'color' ).onChange( render );

					// Add a button to display the selected points
					gui.add({ showPoints: function() {
						const container = document.getElementById('container');
						container.innerHTML = '';

						// Create a new canvas for the selected points
						const canvas = document.createElement('canvas');
						canvas.width = 400;
						canvas.height = 400;
						container.appendChild(canvas);

						// Create a new scene for the selected points
						const selectedScene = new THREE.Scene();

						// Create a new camera for the selected points
						const selectedCamera = new
						const selectedCamera = new THREE.PerspectiveCamera(30, 1, 0.01, 40);
						selectedCamera.position.set(0, 0, 1);
						
											// Create a new renderer for the selected points
					const selectedRenderer = new THREE.WebGLRenderer({ canvas });

					// Create a new geometry for the selected points
					const selectedGeometry = new THREE.Geometry();

					// Add the selected points to the selected geometry
					selectedPoints.forEach(function(point) {
						selectedGeometry.vertices.push(point);
					});

					// Create a new material for the selected points
					const selectedMaterial = new THREE.PointsMaterial({ size: 0.02, color: 0xff0000 });

					// Create a new points object for the selected points
					const selectedPointsObject = new THREE.Points(selectedGeometry, selectedMaterial);

					// Add the selected points object to the selected scene
					selectedScene.add(selectedPointsObject);

					// Set the aspect ratio of the selected camera to match the canvas size
					selectedCamera.aspect = canvas.width / canvas.height;

					// Update the projection matrix of the selected camera
					selectedCamera.updateProjectionMatrix();

					// Render the selected scene with the selected camera and renderer
					selectedRenderer.render(selectedScene, selectedCamera);
				} });

				gui.open();

				render();

			} );

			renderer.domElement.addEventListener('click', selectPoints);
			window.addEventListener( 'resize', onWindowResize );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

			render();

		}

		function render() {

			renderer.render( scene, camera );

		}

		function selectPoints(event) {
			const canvas = renderer.domElement;
			const rect = canvas.getBoundingClientRect();

			// Calculate the mouse position in normalized device coordinates (-1 to +1)
			const mouse = new THREE.Vector2();
			mouse.x = ((event.clientX - rect.left) / canvas.width) * 2 - 1;
			mouse.y = -((event.clientY - rect.top) / canvas.height) * 2 + 1;

			// Raycast from the camera to find the intersected point
			const raycaster = new THREE.Raycaster();
			raycaster.setFromCamera(mouse, camera);
			const intersects = raycaster.intersectObject(points);

			if (intersects.length > 0) {
				selectedPoints.push(intersects[0].point);

				const geometry = new THREE.SphereGeometry(0.01, 32, 32);
				const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
				const sphere = new THREE.Mesh(geometry, material);
				sphere.position.copy(intersects[0].point);
				scene.add(sphere);

				render();
			}
		}

	</script>
</body>
</html>